/***************************************************************************
 *
 * Copyright 2011 Ben van Klinken
 *
 * Licensed to the Apache Software  Foundation (ASF) under one or more
 * contributor  license agreements.  See  the NOTICE  file distributed
 * with  this  work  for  additional information  regarding  copyright
 * ownership.   The ASF  licenses this  file to  you under  the Apache
 * License, Version  2.0 (the  "License"); you may  not use  this file
 * except in  compliance with the License.   You may obtain  a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the  License is distributed on an  "AS IS" BASIS,
 * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY  KIND, either  express or
 * implied.   See  the License  for  the  specific language  governing
 * permissions and limitations under the License.
 *
 * **************************************************************************/


/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.0
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_lucenepp_WRAP_H_
#define SWIG_lucenepp_WRAP_H_

#include <map>
#include <string>


class SwigDirector_Reader : public Lucene::Reader, public Swig::Director {

public:
    SwigDirector_Reader(PyObject *self);
    virtual ~SwigDirector_Reader();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual Lucene::String getClassName();
    virtual int32_t read();
    virtual int32_t read(wchar_t *buffer, int32_t offset, int32_t length);
    virtual int64_t skip(int64_t n);
    virtual void close();
    virtual bool markSupported();
    virtual void mark(int32_t readAheadLimit);
    virtual void reset();
    virtual int64_t length();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class Reader doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[10];
#endif

};


class SwigDirector_FieldSelector : public Lucene::FieldSelector, public Swig::Director {

public:
    SwigDirector_FieldSelector(PyObject *self);
    virtual ~SwigDirector_FieldSelector();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual Lucene::String getClassName();
    virtual Lucene::FieldSelector::FieldSelectorResult accept(Lucene::String const &fieldName);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class FieldSelector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_Analyzer : public Lucene::Analyzer, public Swig::Director {

public:
    SwigDirector_Analyzer(PyObject *self);
    virtual ~SwigDirector_Analyzer();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual Lucene::String getClassName();
    virtual TokenStreamPtr tokenStream(Lucene::String const &fieldName, ReaderPtr reader);
    virtual TokenStreamPtr reusableTokenStream(Lucene::String const &fieldName, ReaderPtr reader);
    virtual int32_t getPositionIncrementGap(Lucene::String const &fieldName);
    virtual int32_t getOffsetGap(FieldablePtr field);
    virtual void close();
    virtual LuceneObjectPtr getPreviousTokenStream();
    virtual LuceneObjectPtr getPreviousTokenStreamSwigPublic() {
      return Lucene::Analyzer::getPreviousTokenStream();
    }
    virtual void setPreviousTokenStream(LuceneObjectPtr stream);
    virtual void setPreviousTokenStreamSwigPublic(LuceneObjectPtr stream) {
      Lucene::Analyzer::setPreviousTokenStream(stream);
    }


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class Analyzer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[9];
#endif

};


class SwigDirector_Filter : public Lucene::Filter, public Swig::Director {

public:
    SwigDirector_Filter(PyObject *self);
    virtual ~SwigDirector_Filter();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual Lucene::String getClassName();
    virtual DocIdSetPtr getDocIdSet(IndexReaderPtr reader);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class Filter doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[3];
#endif

};


class SwigDirector_Similarity : public Lucene::Similarity, public Swig::Director {

public:
    SwigDirector_Similarity(PyObject *self);
    virtual ~SwigDirector_Similarity();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual Lucene::String getClassName();
    virtual double computeNorm(Lucene::String const &fieldName, FieldInvertStatePtr state);
    virtual double lengthNorm(Lucene::String const &fieldName, int32_t numTokens);
    virtual double queryNorm(double sumOfSquaredWeights);
    virtual double tf(int32_t freq);
    virtual double sloppyFreq(int32_t distance);
    virtual double tf(double freq);
    virtual IDFExplanationPtr idfExplain(TermPtr term, SearcherPtr searcher);
    virtual IDFExplanationPtr idfExplain(Lucene::Collection< TermPtr > terms, SearcherPtr searcher);
    virtual double idf(int32_t docFreq, int32_t numDocs);
    virtual double coord(int32_t overlap, int32_t maxOverlap);
    virtual double scorePayload(int32_t docId, Lucene::String const &fieldName, int32_t start, int32_t end, ByteArray payload, int32_t offset, int32_t length);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class Similarity doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[11];
#endif

};


class SwigDirector_Collector : public Lucene::Collector, public Swig::Director {

public:
    SwigDirector_Collector(PyObject *self);
    virtual ~SwigDirector_Collector();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual Lucene::String getClassName();
    virtual void setScorer(ScorerPtr scorer);
    virtual void collect(int32_t doc);
    virtual void setNextReader(IndexReaderPtr reader, int32_t docBase);
    virtual bool acceptsDocsOutOfOrder();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class Collector doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[6];
#endif

};


class SwigDirector_QueryParser : public Lucene::QueryParser, public Swig::Director {

public:
    SwigDirector_QueryParser(PyObject *self, Lucene::LuceneVersion::Version matchVersion, Lucene::String const &field, AnalyzerPtr analyzer);
    SwigDirector_QueryParser(PyObject *self, QueryParserCharStreamPtr stream);
    SwigDirector_QueryParser(PyObject *self, QueryParserTokenManagerPtr tokenMgr);
    virtual ~SwigDirector_QueryParser();
    virtual Lucene::String getClassName();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual QueryPtr TopLevelQuery(Lucene::String const &field);
    virtual QueryPtr ParseQuery(Lucene::String const &field);
    virtual QueryPtr ParseClause(Lucene::String const &field);
    virtual QueryPtr ParseTerm(Lucene::String const &field);
    virtual void ReInit(QueryParserCharStreamPtr stream);
    virtual void ReInit(QueryParserTokenManagerPtr tokenMgr);
    virtual QueryParserTokenPtr getNextToken();
    virtual QueryParserTokenPtr getToken(int32_t index);
    virtual void generateParseException();
    virtual void enable_tracing();
    virtual void disable_tracing();
    virtual void addClause(Lucene::Collection< BooleanClausePtr > clauses, int32_t conj, int32_t mods, QueryPtr q);
    virtual void addClauseSwigPublic(Lucene::Collection< BooleanClausePtr > clauses, int32_t conj, int32_t mods, QueryPtr q) {
      Lucene::QueryParser::addClause(clauses,conj,mods,q);
    }
    virtual QueryPtr getFieldQuery(Lucene::String const &field, Lucene::String const &queryText);
    virtual QueryPtr getFieldQuerySwigPublic(Lucene::String const &field, Lucene::String const &queryText) {
      return Lucene::QueryParser::getFieldQuery(field,queryText);
    }
    virtual QueryPtr getFieldQuery(Lucene::String const &field, Lucene::String const &queryText, int32_t slop);
    virtual QueryPtr getFieldQuerySwigPublic(Lucene::String const &field, Lucene::String const &queryText, int32_t slop) {
      return Lucene::QueryParser::getFieldQuery(field,queryText,slop);
    }
    virtual QueryPtr getRangeQuery(Lucene::String const &field, Lucene::String const &part1, Lucene::String const &part2, bool inclusive);
    virtual QueryPtr getRangeQuerySwigPublic(Lucene::String const &field, Lucene::String const &part1, Lucene::String const &part2, bool inclusive) {
      return Lucene::QueryParser::getRangeQuery(field,part1,part2,inclusive);
    }
    virtual QueryPtr getBooleanQuery(Lucene::Collection< BooleanClausePtr > clauses);
    virtual QueryPtr getBooleanQuerySwigPublic(Lucene::Collection< BooleanClausePtr > clauses) {
      return Lucene::QueryParser::getBooleanQuery(clauses);
    }
    virtual QueryPtr getBooleanQuery(Lucene::Collection< BooleanClausePtr > clauses, bool disableCoord);
    virtual QueryPtr getBooleanQuerySwigPublic(Lucene::Collection< BooleanClausePtr > clauses, bool disableCoord) {
      return Lucene::QueryParser::getBooleanQuery(clauses,disableCoord);
    }
    virtual QueryPtr getWildcardQuery(Lucene::String const &field, Lucene::String const &termStr);
    virtual QueryPtr getWildcardQuerySwigPublic(Lucene::String const &field, Lucene::String const &termStr) {
      return Lucene::QueryParser::getWildcardQuery(field,termStr);
    }
    virtual QueryPtr getPrefixQuery(Lucene::String const &field, Lucene::String const &termStr);
    virtual QueryPtr getPrefixQuerySwigPublic(Lucene::String const &field, Lucene::String const &termStr) {
      return Lucene::QueryParser::getPrefixQuery(field,termStr);
    }
    virtual QueryPtr getFuzzyQuery(Lucene::String const &field, Lucene::String const &termStr, double minSimilarity);
    virtual QueryPtr getFuzzyQuerySwigPublic(Lucene::String const &field, Lucene::String const &termStr, double minSimilarity) {
      return Lucene::QueryParser::getFuzzyQuery(field,termStr,minSimilarity);
    }


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class QueryParser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[21];
#endif

};


class SwigDirector_MultiFieldQueryParser : public Lucene::MultiFieldQueryParser, public Swig::Director {

public:
    SwigDirector_MultiFieldQueryParser(PyObject *self, Lucene::LuceneVersion::Version matchVersion, Lucene::Collection< Lucene::String > fields, AnalyzerPtr analyzer, Lucene::MapStringDouble boosts);
    SwigDirector_MultiFieldQueryParser(PyObject *self, Lucene::LuceneVersion::Version matchVersion, Lucene::Collection< Lucene::String > fields, AnalyzerPtr analyzer);
    virtual ~SwigDirector_MultiFieldQueryParser();
    virtual Lucene::String getClassName();
    virtual void initialize();
    virtual LuceneObjectPtr clone(LuceneObjectPtr other = LuceneObjectPtr());
    virtual int32_t hashCode();
    virtual bool equals(LuceneObjectPtr other);
    virtual int32_t compareTo(LuceneObjectPtr other);
    virtual Lucene::String toString();
    virtual QueryPtr TopLevelQuery(Lucene::String const &field);
    virtual QueryPtr ParseQuery(Lucene::String const &field);
    virtual QueryPtr ParseClause(Lucene::String const &field);
    virtual QueryPtr ParseTerm(Lucene::String const &field);
    virtual void ReInit(QueryParserCharStreamPtr stream);
    virtual void ReInit(QueryParserTokenManagerPtr tokenMgr);
    virtual QueryParserTokenPtr getNextToken();
    virtual QueryParserTokenPtr getToken(int32_t index);
    virtual void generateParseException();
    virtual void enable_tracing();
    virtual void disable_tracing();
    virtual void addClause(Lucene::Collection< BooleanClausePtr > clauses, int32_t conj, int32_t mods, QueryPtr q);
    virtual void addClauseSwigPublic(Lucene::Collection< BooleanClausePtr > clauses, int32_t conj, int32_t mods, QueryPtr q) {
      Lucene::QueryParser::addClause(clauses,conj,mods,q);
    }
    virtual QueryPtr getFieldQuery(Lucene::String const &field, Lucene::String const &queryText);
    virtual QueryPtr getFieldQuerySwigPublic(Lucene::String const &field, Lucene::String const &queryText) {
      return Lucene::MultiFieldQueryParser::getFieldQuery(field,queryText);
    }
    virtual QueryPtr getFieldQuery(Lucene::String const &field, Lucene::String const &queryText, int32_t slop);
    virtual QueryPtr getFieldQuerySwigPublic(Lucene::String const &field, Lucene::String const &queryText, int32_t slop) {
      return Lucene::MultiFieldQueryParser::getFieldQuery(field,queryText,slop);
    }
    virtual QueryPtr getRangeQuery(Lucene::String const &field, Lucene::String const &part1, Lucene::String const &part2, bool inclusive);
    virtual QueryPtr getRangeQuerySwigPublic(Lucene::String const &field, Lucene::String const &part1, Lucene::String const &part2, bool inclusive) {
      return Lucene::MultiFieldQueryParser::getRangeQuery(field,part1,part2,inclusive);
    }
    virtual QueryPtr getBooleanQuery(Lucene::Collection< BooleanClausePtr > clauses);
    virtual QueryPtr getBooleanQuerySwigPublic(Lucene::Collection< BooleanClausePtr > clauses) {
      return Lucene::QueryParser::getBooleanQuery(clauses);
    }
    virtual QueryPtr getBooleanQuery(Lucene::Collection< BooleanClausePtr > clauses, bool disableCoord);
    virtual QueryPtr getBooleanQuerySwigPublic(Lucene::Collection< BooleanClausePtr > clauses, bool disableCoord) {
      return Lucene::QueryParser::getBooleanQuery(clauses,disableCoord);
    }
    virtual QueryPtr getWildcardQuery(Lucene::String const &field, Lucene::String const &termStr);
    virtual QueryPtr getWildcardQuerySwigPublic(Lucene::String const &field, Lucene::String const &termStr) {
      return Lucene::MultiFieldQueryParser::getWildcardQuery(field,termStr);
    }
    virtual QueryPtr getPrefixQuery(Lucene::String const &field, Lucene::String const &termStr);
    virtual QueryPtr getPrefixQuerySwigPublic(Lucene::String const &field, Lucene::String const &termStr) {
      return Lucene::MultiFieldQueryParser::getPrefixQuery(field,termStr);
    }
    virtual QueryPtr getFuzzyQuery(Lucene::String const &field, Lucene::String const &termStr, double minSimilarity);
    virtual QueryPtr getFuzzyQuerySwigPublic(Lucene::String const &field, Lucene::String const &termStr, double minSimilarity) {
      return Lucene::MultiFieldQueryParser::getFuzzyQuery(field,termStr,minSimilarity);
    }


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* protected_method_name, bool val) const
    { swig_inner[protected_method_name] = val;}

private:
    mutable std::map<std::string, bool> swig_inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class MultiFieldQueryParser doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::SwigVar_PyObject vtable[21];
#endif

};


#endif
